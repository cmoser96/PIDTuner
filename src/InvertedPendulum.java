/**
 * The three-dimensional pendulum model
 * 
 * @author serena
 * @since 11/28/16
 */
public class InvertedPendulum {
	private Vector3D pointOfContact, head; // the two ends of the pendulum
	private final double radius; // the length of the pendulum in meters
	
	private double angularVel, angularAccel; // some dynamic properties
	
	private final Vector3D stableEq, unstableEq; // the two equilibrium points
	
	private PID pid; // the controller
	
	
	public InvertedPendulum(double radius, PID pid) {
		this(0, 0, radius, radius, pid);
	}
	
	
	public InvertedPendulum(double x, double y, double z, PID pid) {
		this(x, y, z, Math.sqrt(x * x + y * y + z * z), pid);
	}
	
	
	private InvertedPendulum(double x, double y, double z, double radius, PID pid) {
		this.pointOfContact = new Vector3D(0, 0, 0);
		this.head = new Vector3D(x, y, z);
		this.radius = radius;
		
		this.angularVel = 0;
		this.angularAccel = 0;
		
		this.stableEq = new Vector3D(pointOfContact.x, pointOfContact.y, pointOfContact.z - radius); // the equilibrium points are directly above and below the
		this.unstableEq = new Vector3D(pointOfContact.x, pointOfContact.y, pointOfContact.z + radius); // pivot
		
		this.pid = pid;
	}
	
	
	/**
	 * Calculates and stores the magnitude of the angular acceleration
	 */
	public void computeAcceleration() {
		double theta = getAngleBtwnStable();
		
		this.angularAccel = -9.81 * Math.sin(theta) / this.radius + externalAcceleration();
	}
	
	
	/**
	 * @return the angular acceleration generated by the motor
	 */
	public double externalAcceleration() {
		double thetaDiff = getAngleBtwnUnstable();
		double externalAccel = pid.getCorrection(thetaDiff);
		return externalAccel;
	}
	
	
	/**
	 * Moves the pendulum forward in time by Main.DT milliseconds
	 */
	public void step() {
		computeAcceleration();
		angularVel += angularAccel * Main.DT; // velocity is updated by acceleration
		double dtheta = angularVel * Main.DT;
		double theta = getAngleBtwnStable() + dtheta; // position is updated by velocity
		double z = -Math.cos(theta) * radius;
		double x = Math.sin(theta) * radius; // also, constrain the pendulum to the x-z plane
		head = new Vector3D(x + pointOfContact.x, head.y, z + pointOfContact.z);
	}
	
	
	public Vector3D getPointOfContact() {
		return pointOfContact;
	}
	
	
	public Vector3D getHead() {
		return head;
	}
	
	
	/**
	 * @return the angular distance between the pendulum and <b>k</b>
	 */
	public double getAngleBtwnUnstable() {
		double absVal = unstableEq.absAngleBetween(head);
		
		if (head.x > unstableEq.x) // return negative values when left of the y-z plane
			return absVal;
		else
			return -absVal;
	}
	
	
	/**
	 * @return the angular distance between the pendulum and -<b>k</b>
	 */
	public double getAngleBtwnStable() {
		double absVal = stableEq.absAngleBetween(head);
		
		if (head.x > stableEq.x) // return negative values when left of the y-z plane
			return absVal;
		else
			return -absVal;
	}
	
	
	/**
	 * Sets <code>head</code> to <code>pos</code>, and zeroes the angular acceleration and velocity
	 */
	public void resetToPos(Vector3D pos) {
		this.head = pos;
		this.angularAccel = 0.0;
		this.angularVel = 0.0;
	}
	
	
	public PID getPID() {
		return pid;
	}
	
}
